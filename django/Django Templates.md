## Django Templates

Django 模板系统, 用以提供动态生成 HTML 的便捷方式.  

一个模板通常包含了想要输出 HTML 的静态内容, 以及一些关于如何插入动态内容的特定语法. 

Django 项目可以配置一个或多个模板引擎. Django模板系统称为 Django template language(DTL). 并自带流行的 Jinjia2 模板系统. 第三方的模板系统后端也可使用. 也可以自定义模板后端. 

**模板系统不能够防范不受信任的模板作者. 站点不应该允许其用户提供自己的模板, 因为模板的作者可以利用模板执行 XSS 攻击, 非法获取含有敏感信息的模板变量, 等等.** 

### Django 模板语言

#### 语法

详细语法参考[链接](https://docs.djangoproject.com/en/5.1/ref/templates/language/). 

模板通过上下文呈现. 模板在呈现时会将上下文中变量的值替换至变量的位置, 并执行标签. Django 的模板语言涉及 4 种结构: 

##### 变量

变量将从上下文种输出自身的值, 上下文是一个字典类型的数据. 若变量被解析为可调用函数, 那么模板系统将会执行不带任何参数的调用并将其结果作为值返回. 

```python
My first name is {{ first_name }}. My last name is {{ last_name }}.
# With a context of {'first_name': 'John', 'last_name': 'Doe'}, this template renders to:
# My first name is John. My last name is Doe.

{{ my_dict.key }}
{{ my_object.attribute }}
{{ my_list.0 }}
```

##### 标签

标签提供在渲染过程中的任意操作逻辑. 例如执行判断或执行循环, 从数据库中获取内容, 甚至是获取其他模板标签. 

```python
# Tags are surrounded by {% and %} like this:
{% csrf_token %}

# Most tags accept arguments:
{% cycle 'odd' 'even' %}

# Some tags require beginning and ending tags:
{% if user.is_authenticated %}Hello, {{ user.username }}.{% endif %}
```

##### 过滤器

过滤器可以处理变量的值或标签的参数. 

```python
# They look like this:
{{ django|title }}
# With a context of {'django': 'the web framework for perfectionists with deadlines'}, this template renders to:
# The Web Framework For Perfectionists With Deadlines

{{ my_date|date:"Y-m-d" }}
```

##### 注释

```python
{# this won't be rendered #}

# A {% comment %} tag provides multi-line comments.
{% comment "Optional note" %}
    <p>Commented out text with {{ create_date|date:"c" }}</p>
{% endcomment %}
```

#### 模板继承

- 若需要获得在父模板中定义的块内容, 使用 {{ block.super }}, 这个变量在当你需要为父模板中的内容添加一些内容而不希望彻底重写它时非常有用. 

- 当在模板中加载自定义的标签或过滤器库时, 这些标签和过滤器仅在当前模板下可用, 父模板和子模版东都不可用. 需要另外再加载. 

#### 模板转义

为防止Cross-Site Scripting(XSS), 即跨站脚本攻击. 模板转义默认全局开启, 当需要转义某些内容时参考如下: 

```python

# For individual variables
This will be escaped: {{ data }}
This will not be escaped: {{ data|safe }}
# This will be escaped: &lt;b&gt;
# This will not be escaped: <b>

# For template blocks
{% autoescape off %}
    Hello {{ name }}
{% endautoescape %}
# The autoescape tag takes either on or off as its argument.
Auto-escaping is on by default. Hello {{ name }}
{% autoescape off %}
    This will not be auto-escaped: {{ data }}.
    Nor this: {{ other_data }}
    {% autoescape on %}
        Auto-escaping applies again: {{ name }}
    {% endautoescape %}
{% endautoescape %}
```

**自动转义关闭后, 会将其影响范围传递给继承当前模板的子模板或块.** 

```python
# base.html
{% autoescape off %}
<h1>{% block title %}{% endblock %}</h1>
{% block content %}
{% endblock %}
{% endautoescape %}

# child.html
{% extends "base.html" %}
{% block title %}This &amp; that{% endblock %}
{% block content %}{{ greeting }}{% endblock %}

# result
<h1>This &amp; that</h1>
<b>Hello!</b>
```

#### 组件

##### Engine

`django.template.Engine` 封装了 Django 模板系统实例. 一般不直接使用引擎, 除非要在 Django 项目之外使用 Django 模板语言. 

`django.template.backends.django.DjangoTemplates` 用于将引擎简单封装至 Django 模板后端 API. 

##### Template

表示一个编译后的模板对象. 

##### Context

##### Loaders

##### Context Processors

### 模板引擎支持

#### 配置

```python
# It’s a list of configurations, one for each engine. The default value is empty. 
# The settings.py generated by the startproject command defines a more useful value:
TEMPLATES = [
    {
        # BACKEND is a dotted Python path to a template engine class implementing Django’s template backend API.
        # The built-in backends are django.template.backends.django.DjangoTemplates and django.template.backends.jinja2.Jinja2.
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        # DIRS defines a list of directories where the engine should look for template source files, in search order.
        "DIRS": [],
        # APP_DIRS tells whether the engine should look for templates inside installed applications. Each backend defines a conventional name for the subdirectory inside applications where its templates should be stored.
        "APP_DIRS": True,
        # While uncommon, it’s possible to configure several instances of the same backend with different options. In that case you should define a unique NAME for each engine.
        
        # OPTIONS contains backend-specific settings.
        "OPTIONS": {
            # ... some options here ...
        },
    },
]
```

#### 用法

##### django.template.loader

此模块定义了两个函数以加载模板. 

`get_template(template_name, using=None)` [[source\]](https://github.com/django/django/blob/stable/5.1.x/django/template/loader.py#L5) 

加载模板并返回一个 `Template` 对象, 具体类型由使用的模板后端决定.  若要限制使用哪个模板引擎来搜索模板, 使用 `using=` 来指定引擎的名称 `NAME` 

`select_template(template_name_list, using=None)` [[source\]](https://github.com/django/django/blob/stable/5.1.x/django/template/loader.py#L22)

与 `get_template()` 类似, 但搜素给定列表中符合条件的第一个模板. 

##### Template.render(context=None, request=None)

通过给定的上下文呈现当前模板. 

- If `context` is provided, it must be a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict). If it isn’t provided, the engine will render the template with an empty context.

- If `request` is provided, it must be an [`HttpRequest`](https://docs.djangoproject.com/en/5.1/ref/request-response/#django.http.HttpRequest). Then the engine must make it, as well as the CSRF token, available in the template. How this is achieved is up to each backend.

##### render_to_string(template_name, context=None, request=None, using=None)

通过 `get_template()` 加载模板并调用其 `render()` 方法, 参考[链接](https://docs.djangoproject.com/en/5.1/topics/http/shortcuts/#django.shortcuts.render)  

#### 内置后端

##### class DjangoTemplates

支持的 OPTION : 

- `autoescape` : 控制是否自动转义 HTML 的布尔值, 默认为 True
- `context_processors` : 当模板通过请求来呈现时, 用来填充上下文的可调用函数. 
- `debug` : 默认为 `DEBUG` 设置的值. 
- `loaders` : 
- `string_if_invalid` : 模板系统为无效变量使用的字符串. 默认为空字符串. 
- `file_charset` : 用来读取硬盘上的模板文件使用的字符集, 默认 `utf-8` 
- `libraries` : 
- `builtins` : 指向模板标签模块, 以添加为内置标签. 内置标签和过滤器可以无需 `{% load %}` 使用. 

##### class Jinjia2

### 自定义过滤器和标签的代码结构

一般建议将自定义标签和过滤器放置在与其相关的 APP 应用目录内, 若有必要, 也可将其放在一个全新 APP

应用目录内. 当 Django 应用被添加至 `INSTALL_APP` 时, 其中定义在约定位置下的所有标签都将自动可用于加载. 所有自定义的标签和过滤器应放在 `templatetags` 目录下, 模块文件的名称即为要加载的标签名称, 目录结构如下: 

```python
polls/
    __init__.py
    models.py
    templatetags/
        __init__.py
        poll_extras.py
    views.py
    
# And in your template you would use the following:
{% load poll_extras %}
```

为了成为有效的标签库, 模块文件必须定义一个全局变量 `register` 为 `template.Library` 的实例. 如下: 

```python
from django import template

register = template.Library()
```

可选地, 模板标签模块也可以通过 `libraries` 变量注册到 `DjangoTemplate` . 这样可以不用安装应用, 也能直接加载标签模块使用. 

### 创建自定义模板过滤器

自定义过滤器作为 Python 函数, 接受一个或两个参数: 

- 输入的变量值(不必须是字符串)

- 参数值(可以有默认值)

```python
# For example, in the filter {{ var|foo:"bar" }}, the filter foo would be passed the variable var and the argument "bar".

def cut(value, arg):
    """Removes all values of arg from the given string"""
    return value.replace(arg, "")

# And here’s an example of how that filter would be used:
{{ somevariable|cut:"0" }}

```

模板语言不提供异常处理机制, 任何从模板过滤器抛出的异常将会直接输出为服务器错误. 因此, 在有可选的默认输出值时, 过滤器函数应该避免抛出异常. 

#### 注册自定义过滤器

`django.template.Library.filter()`

过滤器注册函数接收两个参数, 和其他关键字参数

- 过滤器名称(字符串)
- 函数句柄

```python
register.filter("cut", cut)
register.filter("lower", lower)

# 也可以指直接使用装饰器注册, 此时若省略名称参数, 装饰器自动使用函数名称
@register.filter(name="cut")
def cut(value, arg):
    return value.replace(arg, "")

@register.filter
def lower(value):
    return value.lower()
```

#### 只接受字符串的模板过滤器

`django.template.defaultfilters.stringfilter()`

```python
from django import template
from django.template.defaultfilters import stringfilter

register = template.Library()

# If you’re writing a template filter that only expects a string as the first argument, you should use the decorator stringfilter. This will convert an object to its string value before being passed to your function:

@register.filter
@stringfilter
def lower(value):
    return value.lower()
```

#### 过滤器及自动转义

模板编码中的两种字符串: 

- Raw Strings . 原生 Python 字符串, 当自动转义生效时, 在输出时将被转义

- Safe Strings . 被标记为安全的字符串, 在输出时不会被进一步转义. 

......

#### 过滤器及时区

如果需要自定义用来操作 `datetime` 对象的过滤器, 可以使用 `expect_localtime` 标志. 

```python
@register.filter(expects_localtime=True)
def businesshours(value):
    try:
        return 9 <= value.hour < 17
    except AttributeError:
        return ""
```

**When this flag is set, if the first argument to your filter is a time zone aware datetime, Django will convert it to the current time zone before passing it to your filter when appropriate, according to [rules for time zones conversions in templates](https://docs.djangoproject.com/en/5.1/topics/i18n/timezones/#time-zones-in-templates).**

### 创建自定义标签

#### Simple Tag

`django.template.Library.simple_tag()`

```python
import datetime
from django import template

register = template.Library()

@register.simple_tag
def current_time(format_string):
    return datetime.datetime.now().strftime(format_string)

# If your template tag needs to access the current context, you can use the takes_context argument when registering your tag:
@register.simple_tag(takes_context=True)
def current_time(context, format_string):
    timezone = context["timezone"]
    return your_get_current_time_method(timezone, format_string)
```

```python
# simple_tag functions may accept any number of positional or keyword arguments. For example:

@register.simple_tag
def my_tag(a, b, *args, **kwargs):
    warning = kwargs["warning"]
    profile = kwargs["profile"]
    ...
    return ...

# Then in the template any number of arguments, separated by spaces, may be passed to the template tag. Like in Python, the values for keyword arguments are set using the equal sign (”=”) and must be provided after the positional arguments. For example:
{% my_tag 123 "abcd" book.title warning=message|lower profile=user.profile %}
```

可以将标签的输出结果存储为变量, 而不是直接输出. 通过 `as` 指定存储的变量名称. 

```python
{% current_time "%Y-%m-%d %I:%M %p" as the_time %}
<p>The time is {{ the_time }}.</p>
```

#### Inclusion Tag

定义函数: 

```python
def show_results(poll):
    choices = poll.choice_set.all()
    return {"choices": choices}
```

定义模板文件: 

```python
<ul>
{% for choice in choices %}
    <li> {{ choice }} </li>
{% endfor %}
</ul>
```

注册 inclusion tag : 

```python
# Here, register is a django.template.Library instance, as before
@register.inclusion_tag("results.html")
def show_results(poll): ...

# Alternatively it is possible to register the inclusion tag using a django.template.Template instance:
from django.template.loader import get_template

t = get_template("results.html")
register.inclusion_tag(t)(show_results)
```

指定 `takes_context` , 可以自动获取上下文作为变量. 此时便不需要再向模板标签传递参数. 但函数需要定义 `context` 参数以接收传递的上下文. 

```python
@register.inclusion_tag("link.html", takes_context=True)
def jump_link(context):
    return {
        "link": context["home_link"],
        "title": context["home_title"],
    }
    
# template: 
Jump directly to <a href="{{ link }}">{{ title }}</a>.

# call that custom tag: 
{% jump_link %}

# inclusion_tag functions may accept any number of positional or keyword arguments. For example:
@register.inclusion_tag("my_template.html")
def my_tag(a, b, *args, **kwargs):
    warning = kwargs["warning"]
    profile = kwargs["profile"]
    ...
    return ...

{% my_tag 123 "abcd" book.title warning=message|lower profile=user.profile %}
```

### 创建底层自定义标签

#### 模板系统的工作流程

模板系统的工作原理分两步, 编译和呈现, 为了定义个性化的模板标签, 你可以指定编译具体实现及呈现如何具体实现. 

当 Django 编译一个模板时, 它将原始模板文本拆分为多个 `nodes`. 每一个 `node`(节点) 是一个 `django.template.Node` 实例并拥有 `render()` 方法. 一个经过编译的模板是由 `Node` 对象形成的列表, 当对其调用 `render()` 方法时, 模板将在给定的上下文中, 对列表中的每一个 `Node` 分别调用 `render()` 方法, 结果将拼接在一起以形成模板的输出. 

因此, 要定义个性化的模板标签, 需要指定原始模板标签如何转化为节点(即编译功能), 以及实现节点的呈现函数. 

#### 实现编译函数

模板解析器对遇到的每个模板标签, 都会调用一个 Python 函数, 并将标签内容和解释器对象作为参数传入, 这个函数负责处理标签内容并返回一个节点实例. 

**通过举例来实现一个模板标签:** 

```html
<p>The time is {% current_time "%Y-%m-%d %I:%M %p" %}.</p>
```

**此函数的解析器应该获取参数并创建一个节点对象:**

```python
from django import template

def do_current_time(parser, token):
    try:
        # split_contents() knows not to split quoted strings.
        tag_name, format_string = token.split_contents()
    except ValueError:
        raise template.TemplateSyntaxError(
            "%r tag requires a single argument" % token.contents.split()[0]
        )
    if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
        raise template.TemplateSyntaxError(
            "%r tag's argument should be in quotes" % tag_name
        )
    return CurrentTimeNode(format_string[1:-1])
```

**注:** 

- `parser` 是模板解释器对象, 在这个例子中我们没有用到它
- `token.contents` 是标签的原始内容. 在我们的例子中, 即 'current_time "%Y-%m-%d %I:%M:%p"'
- `token.split_contents()` 方法以空格为分隔符拆分字符串, 但会保留引号的结构; `token.contents.split()` 则会将所有空格都作为分隔符拆分字符串. 
- 这个函数将对语法错误抛出 `django.template.TemplateSyntaxError` 并给出帮助信息 
- 在异常中使用 `tag_name` 变量, 而不是硬编码标签名称. 
- 此例中, 函数返回一个 `CurrentTimeNode` 对象, 并传递所有此标签需要携带的信息(即输入的参数字符串). 在此例中为 "**%Y-%m-%d** **%I:%M** **%p**", 其中头部和尾部的字符串符号被去掉了. 

#### 编写渲染器

第二步即编写自定义标签, 以定义 `Node` 子类并实现其 `render()` 方法. 接着前文的例子, 我们需要定义 `CurrentTimeNode`

```python
import datetime
from django import template

class CurrentTimeNode(template.Node):
    def __init__(self, format_string):
        self.format_string = format_string

    def render(self, context):
        return datetime.datetime.now().strftime(self.format_string)
```

**注:** 

- 在生产环境中, `render()` 方法调用失败时应静默. 在一些调试环境下可以抛出异常以方便调试. 

#### 关于自动转义

除 `simple_tag()` 之外, 所有的模板标签都不会经过自动转义过滤器处理. 

若 `render()` 方法中会将结果存储进上下文变量, 应考虑是否调用 `mark_safe()` 来将变量标记为安全字符串. 当变量最终呈现时, 其会受到那时自动转义设置是否生效的影响. 

此外, 若模板标签创建了一个新的上下文变量以供后续渲染, 也可以设置自动转义变量为当前上下文的对应值, `Context` 类的初始化方法可以接收自动转义变量参数: 

```python
from django.template import Context


def render(self, context):
    # ...
    new_context = Context({"var": obj}, autoescape=context.autoescape)
    # ... Do something with new_context ...
    
def render(self, context):
    t = context.template.engine.get_template("small_fragment.html")
    return t.render(Context({"var": obj}, autoescape=context.autoescape))
```

若我们忽略了此设置, 结果可能总是被自动转义, 这在设置 `{% autoescape off %}` 时是我们不想要的结果. 

#### 关于线程安全



#### 注册标签

```python
register.tag("current_time", do_current_time)

# 也可使用装饰器注册
@register.tag(name="current_time")
def do_current_time(parser, token): ...

# 若省略name参数, 则自动使用函数名称作为标签名称
@register.tag
def shout(parser, token): ...
```

#### 向标签传递模板变量



#### 使用标签设置上下文变量

`render()` 方法总应该返回字符串. 

```python
import datetime
from django import template


class CurrentTimeNode2(template.Node):
    def __init__(self, format_string):
        self.format_string = format_string

    def render(self, context):
        context["current_time"] = datetime.datetime.now().strftime(self.format_string)
        return ""
    
    
# use 
{% current_time "%Y-%m-%d %I:%M %p" %}<p>The time is {{ current_time }}.</p>
```

在上下文中设置的任何变量都仅在它被赋值的块中可用. 

#### 解析到另一个块标签



#### 解析到另一个块标签并保存内容

